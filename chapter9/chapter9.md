# Order-Book Trading Algorithms {#sec:order-book-algos-chapter}

In this chapter, we venture into the world of Algorithmic Trading and specifically, we cover a couple of problems involving a trading *Order Book* that can be cast as Markov Decision Processes, and hence tackled with Dynamic Programming or Reinforcement Learning. We start the chapter by covering the basics of how trade orders are submitted and executed on an *Order Book*, a structure that allows for efficient transactions between buyers and sellers of a financial asset. Without loss of generality, we refer to the financial asset being traded on the Order Book as a "stock" and the number of units of the asset as "shares". Next we will explain how a large trade can significantly shift the Order Book, a phenomenon known as *Price Impact*. Finally, we will cover the two algorithmic problems that can be cast as MDPs. The first problem is Optimal Execution of the sales of a large number of shares of a stock so as to yield the maximum utility of proceeds from the sale over a finite horizon. This involves breaking up the sale of the shares into appropriate pieces and selling those pieces at the right times so as to achieve the  goal of maximizing the utility of sales proceeds. Hence, it is an MDP  Control problem where the actions are the number of shares sold at each time step. The second problem is Optimal Market-Making, i.e., the optimal "bid"s (willingness to buy a certain number of shares at a certain price) and "ask"s (willingness to sell a certain number of shares at a certain price) to be submitted on the Order Book. Again, by optimal, we mean maximization of the utility of revenues generated by the market-maker over a finite-horizon (market-makers generate revenue through the spread, i.e. gap, between the bid and ask prices they offer). This is also an MDP Control problem where the actions are the bid and ask prices along with the bid and ask shares at each time step.

![Trading Order Book \label{fig:trading_order_book}](./chapter9/order_book.png "Trading Order Book")

## Basics of Order Book and Price Impact

Some of the financial literature refers to the Order Book as Limit Order Book (abbreviated as LOB) but we will stick with the lighter language - Order Book, abbreviated as OB. The Order Book is essentially a data structure that facilitates matching stock buyers with stock sellers (i.e., an electronic marketplace). Figure \ref{fig:trading_order_book} depicts a simplified view of an order book. In this order book market, buyers and sellers express their intent to trade by submitting bids (intent to buy) and "ask"s (intent to sell). These expressions of intent to buy or sell are known as Limit Orders (abbreviated as LO). The word "limit" in Limit Order refers to the fact that one is interested in buying only below a certain price level (and likewise, one is interested in selling only above a certain price level). Each LO is comprised of a price $P$ and number of shares $N$. A bid, i.e., Buy LO $(P, N)$ states willingness to buy $N$ shares at a price less than or equal to $P$. Likewise, an ask, i.e., a Sell  LO $(P, N)$ states willingness to sell $N$ shares at a price greater than or equal to $P$.

Note that multiple traders might submit LOs with the same price. The order book aggregates the number of shares for each unique price, and the OB data structure is typically presented for trading in the form of this aggregated view. Thus, the OB data structure can be represented as two sorted lists of (Price, Size) pairs:

$$\text{Buy LOs (Bids): } [(P_i^{(b)}, N_i^{(b)}) \mid 0 \leq i < m], P_i^{(b)} > P_j^{(b)} \mbox{ for } i < j$$
$$\text{Sell LOs (Asks): } [(P_i^{(a)}, N_i^{(a)}) \mid 0 \leq i < n], P_i^{(a)} < P_j^{(a)} \mbox{ for } i < j$$

Note that the Buy LOs are arranged in descending order and the Sell LOs are arranged in ascending order to signify the fact that the beginning of each list consists of the most important (best-price) LOs.

Now let's learn about some of the standard terminology:

* We refer to $P_0^{(b)}$ as *The Bid Price* (often lightened to the single word *Bid* ) to signify that it is the highest offer to buy and hence, the *best* price for a seller to transact with.
* Likewise, we refer to $P_0^{(a)}$ as *The Ask Price* (often lightened to the single word *Ask*) to signify that it is the lowest offer to sell and hence, the *best* price for a buyer to transact with.
* $\frac {P_0^{(a)} + P_0^{(b)}} 2$ is refered to as the *The Mid Price* (often lightened to the single word *Mid*).
* $P_0^{(a)} - P_0^{(b)}$ is refered to as *The Bid-Ask Spread* (often lightened to the single word *Spread*).
* $P_{n-1}^{(a)} - P_{m-1}^{(b)}$ is refered to as *The Market Depth* (often lightened to the single word *Depth*).

Although an actual real-world trading order book has many other details, we believe this simplified coverage is adequate for the purposes of core understanding of order book trading and to navigate the problems of optimal order execution and optimal market-making. Apart from Limit Orders, traders can express their interest to buy/sell with another type of order - a *Market Order* (abbreviated as MO). A Market Order (MO) states one's intent to buy/sell $N$ shares at the *best possible price(s)* available on the OB at the time of MO submission. So, an LO is keen on price and not so keen on time (willing to wait to get the price one wants) while an MO is keen on time (desire to trade right away) and not so keen on price (will take whatever the best LO price is on the OB). So now let us understand the actual transactions that happens between LOs and MOs (buy and sell interactions, and how the OB changes as a result of these interactions). Firstly, we note that in normal trading activity, a newly submitted sell LO's price is typically above the price of the best buy LO on the OB. But if a new sell LO's price is less than or equal to the price of the best buy LO's price, we say that the *market has crossed* (to mean that the range of bid prices and the range of ask prices have intersected), which results in an immediate transaction that eats into the OB's Buy LOs.

Precisely, a new Sell LO $(P,N)$ potentially transacts with (and hence, removes) the best Buy LOs on the OB.

\begin{equation}
\text{Removal: } [(P_i^{(b)}, \min(N_i^{(b)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(b)}))) \mid (i: P_i^{(b)} \geq P)]
\label{eq:lo_sell_remove}
\end{equation}

After this removal, it potentially adds the following LO to the asks side of the OB:

\begin{equation}
(P, \max(0, N - \sum_{i: P_i^{(b)} \geq P}  N_i^{(b)}))
\label{eq:lo_sell_add}
\end{equation}

Likewise, a new Buy MO $(P,N)$ potentially transacts with (and hence, removes) the best Sell LOs on the OB

\begin{equation}
\text{Removal: } [(P_i^{(a)}, \min(N_i^{(a)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(a)}))) \mid (i: P_i^{(a)} \leq P)]
\label{eq:lo_buy_remove}
\end{equation}

After this removal, it potentially adds the following to the bids side of the OB:

\begin{equation}
(P, \max(0, N - \sum_{i: P_i^{(a)} \leq P}  N_i^{(a)}))
\label{eq:lo_buy_add}
\end{equation}

When a Market Order (MO) is submitted, things are simpler. A Sell Market Order of $N$ shares will remove the best Buy LOs on the OB.

\begin{equation}
\mbox{Removal: } [(P_i^{(b)}, \min(N_i^{(b)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(b)}))) \mid 0 \leq i < m]
\label{eq:mo_sell_remove}
\end{equation}

The sales proceeds for this MO is:

\begin{equation}
\sum_{i=0}^{m-1} P_i^{(b)} \cdot (\min(N_i^{(b)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(b)})))
\label{eq:mo_sell_proceeds}
\end{equation}

We note that if $N$ is large, the sales proceeds for this MO can be significantly lower than the best possible sales proceeds ($=N \cdot P_0^{(b)}$), which happens if $N \leq N_0^{(b)}$. Note also that if $N$ is large, the new Bid Price (new value of $P_0^{(b)}$) can be significantly lower than the Bid Price before the MO was submitted (because the MO "eats into" a significant volume of Buy LOs on the OB). This "eating into" the Buy LOs on the OB and consequent lowering of the Bid Price (and hence, Mid Price) is known as *Price Impact* of an MO (more specifically, as the *Temporary Price Impact* of an MO). We use the word "temporary" because subsequent to this "eating into" the Buy LOs of the OB (and consequent, "hole", ie., large Bid-Ask Spread), market participants will submit "replenishment LOs" (both Buy LOs and Sell LOs) on the OB. These replenishments LOs would typically mitigate the Bid-Ask Spread and the eventual settlement of the Bid/Mid/Ask Prices constitutes what we call *Permanent Price Impact* - which refers to the changes in OB Bid/Mid/Ask prices relative to the corresponding prices before submission of the MO. 

Likewise, a Buy Market Order of $N$ shares will remove the best Sell LOs on the OB

\begin{equation}
\mbox{Removal: } [(P_i^{(a)}, \min(N_i^{(a)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(a)}))) \mid 0 \leq i < n]
\label{eq:mo_buy_remove}
\end{equation}

The purchase bill for this MO is:

\begin{equation}
\sum_{i=0}^{n-1} P_i^{(a)} \cdot (\min(N_i^{(a)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(a)})))
\label{eq:mo_sell_proceeds}
\end{equation}

If $N$ is large, the purchase bill for this MO can be significantly lower than the best possible purchase bill ($=N \cdot P_0^{(a)}$), which happens if if $N \leq N_0^{(a)}$. All that we wrote above in terms of Temporary and Permanent Price Impact naturally apply in the opposite direction for a Buy MO.

We refer to all of the above-described OB movements, including both temporary and permanent Price Impacts broadly as *Order Book Dynamics*.  There is considerable literature on modeling Order Book Dynamics and some of these models can get fairly complex in order to capture various real-world nuances. Much of this literature is beyond the scope of this book. In this chapter, we will cover a few simple models for how a sell MO will move the OB's *Bid Price* (rather than a model for how it will move the entire OB). The model for how a buy MO will move the OB's *Ask Price* is naturally identical.

Now let's write some code that models how LOs and MOs interact with the OB. We write a class `OrderBook` that represents the Buy and Sell Limit Orders on the Order Book, which are each represented as a sorted sequence of the type `DollarsAndShares`, which is a `dataclass` we created to represent any pair of a dollar amount (`dollar: float`) and number of shares (`shares: int`). Sometimes, we use `DollarsAndShares` to represent an LO (pair of price and shares) as in the case of the sorted lists of Buy and Sell LOs. At other times, we use `DollarsAndShares` to represent the pair of total dollars transacted and total shares transacted when an MO is executed on the OB. The `OrderBook` maintains a price-descending sequence of `PriceSizePairs` for Buy LOs (`descending_bids`) and a price-ascending sequence of `PriceSizePairs` for Sell LOs (`ascending_asks`). We write the basic methods to get the `OrderBook`'s highest bid price (method `bid_price`), lowest ask price (method `ask_price`), mid price (method `mid_price`), spread between the highest bid price and lowest ask price (method `bid_ask_spread`), and market depth (method `market_depth`).

```python
@dataclass(frozen=True)
class DollarsAndShares:

    dollars: float
    shares: int

PriceSizePairs = Sequence[DollarsAndShares]

@dataclass(frozen=True)
class OrderBook:

    descending_bids: PriceSizePairs
    ascending_asks: PriceSizePairs

    def bid_price(self) -> float:
        return self.descending_bids[0].dollars

    def ask_price(self) -> float:
        return self.ascending_asks[0].dollars

    def mid_price(self) -> float:
        return (self.bid_price() + self.ask_price()) / 2

    def bid_ask_spread(self) -> float:
        return self.ask_price() - self.bid_price()

    def market_depth(self) -> float:
        return self.ascending_asks[-1].dollars - \
            self.descending_bids[-1].dollars
```

Next we want to write methods for LOs and MOs to interact with the `OrderBook`. Notice that each of Equation \eqref{eq:lo_sell_remove} (new Sell LO potentially removing some of the beginning of the Buy LOs on the OB), Equation \eqref{eq:lo_buy_remove} (new Buy LO potentially removing some of the beginning of the Sell LOs on the OB), Equation \eqref{eq:mo_sell_remove} (Sell MO removing some of the beginning of the Buy LOs on the OB) and Equation \eqref{eq:mo_buy_remove} (Buy MO removing some of the beginning of the Sell LOs on the OB) all perform a common core function - they "eat into" the most significant LOs (on the opposite side) on the OB. So we first write a `@staticmethod eat_book` for this common function.

`eat_book` takes as input a `ps_pairs: PriceSizePairs` (representing one side of the OB) and the number of `shares: int` to buy/sell. Notice `eat_book`'s return type: `Tuple[DollarsAndShares, PriceSizePairs]`. The returned `DollarsAndShares` represents the pair of dollars transacted and the number of shares transacted (with number of shares transacted being less than or equal to the input `shares`). The returned `PriceSizePairs` represents the remainder of `ps_pairs` after the transacted number of shares have eaten into the input `book`. `eat_book` first deletes (i.e. "eats up") as much of the *beginning* of the `ps_pairs: PriceSizePairs` data structure as it can (basically matching the input number of shares with an appropriate number of shares at the beginning of the `ps_pairs: PriceSizePairs` input). Note that the returned `PriceSizePairs` is a separate data structure, ensuring the immutability of the input `ps_pairs: PriceSizePairs`. 

```python
    @staticmethod
    def eat_book(
        ps_pairs: PriceSizePairs,
        shares: int
    ) -> Tuple[DollarsAndShares, PriceSizePairs]:
        rem_shares: int = shares
        dollars: float = 0.
        for i, d_s in enumerate(ps_pairs):
            this_price: float = d_s.dollars
            this_shares: int = d_s.shares
            dollars += this_price * min(rem_shares, this_shares)
            if rem_shares < this_shares:
                return (
                    DollarsAndShares(dollars=dollars, shares=shares),
                    [DollarsAndShares(
                        dollars=this_price,
                        shares=this_shares - rem_shares
                    )] + list(ps_pairs[i+1:])
                )
            else:
                rem_shares -= this_shares

        return (
            DollarsAndShares(dollars=dollars, shares=shares - rem_shares),
            []
        )
```

Now we are ready to write the method `sell_limit_order` which takes Sell MO Price and Sell MO shares as input. As you can see in the code below, it removes (if it "crosses") an appropriate number of shares on the Buy LO side of the OB (using the `@staticmethod eat_book`), and then potentially adds an appropriate number of shares at the Sell MO Price on the Sell MO side of the OB. `sell_limit_order` returns a new instance of `OrderBook` representing the altered OB after this transaction (note that we ensure the immutability of `self` by returning a newly-created `OrderBook`). We urge you to read the code below carefully as there are many subtle details that are handled in the code.

```python
from dataclasses import replace

    def sell_limit_order(self, price: float, shares: int) -> OrderBook:
        index: Optional[int] = next((i for i, d_s
                                     in enumerate(self.descending_bids)
                                     if d_s.dollars < price), None)
        eligible_bids: PriceSizePairs = self.descending_bids \
            if index is None else self.descending_bids[:index]
        ineligible_bids: PriceSizePairs = [] if index is None else \
            self.descending_bids[index:]

        d_s, rem_bids = OrderBook.eat_book(eligible_bids, shares)
        new_bids: PriceSizePairs = list(rem_bids) + list(ineligible_bids)
        rem_shares: int = shares - d_s.shares

        if rem_shares > 0:
            new_asks: List[DollarsAndShares] = list(self.ascending_asks)
            index1: Optional[int] = next((i for i, d_s
                                          in enumerate(new_asks)
                                          if d_s.dollars >= price), None)
            if index1 is None:
                new_asks.append(DollarsAndShares(
                    dollars=price,
                    shares=rem_shares
                ))
            elif new_asks[index1].dollars != price:
                new_asks.insert(index1, DollarsAndShares(
                    dollars=price,
                    shares=rem_shares
                ))
            else:
                new_asks[index1] = DollarsAndShares(
                    dollars=price,
                    shares=new_asks[index1].shares + rem_shares
                )
            return OrderBook(
                ascending_asks=new_asks,
                descending_bids=new_bids
            )
        else:
            return replace(
                self,
                descending_bids=new_bids
            )
```

Next, we write the easier method `sell_market_order` which takes as input the number of shares to be sold (as a market order). `sell_market_order` transacts with the appropriate number of shares on the Buy LOs side of the OB (removing those many shares from the Buy LOs side). It returns a pair of `DollarsAndShares` type and `OrderBook` type. The returned `DollarsAndShares` represents the pair of dollars transacted and the number of shares transacted (with number of shares transacted being less than or equal to the input `shares`). The returned `OrderBook` represents the remainder of the OB after the transacted number of shares have eaten into the Buy LOs side of the OB. Note that the returned `OrderBook` is a newly-created data structure, ensuring the immutability of `self`.

```python
    def sell_market_order(
        self,
        shares: int
    ) -> Tuple[DollarsAndShares, OrderBook]:
        d_s, rem_bids = OrderBook.eat_book(
            self.descending_bids,
            shares
        )
        return (d_s, replace(self, descending_bids=rem_bids))
```

We won't list the methods `buy_limit_order` and `buy_market_order` here as they are completely analogous (you can find the entire code for `OrderBook` in the file [rl/chapter9/order_book.py](https://github.com/TikhonJelvis/RL-book/blob/master/rl/chapter9/order_book.py)). Now let us test out this code by creating a sample `OrderBook` and submitting some LOs and MOs to transact with the `OrderBook`.

```python
bids: PriceSizePairs = [DollarsAndShares(
    dollars=x,
    shares=poisson(100. - (100 - x) * 10)
) for x in range(100, 90, -1)]
asks: PriceSizePairs = [DollarsAndShares(
    dollars=x,
    shares=poisson(100. - (x - 105) * 10)
) for x in range(105, 115, 1)]

ob0: OrderBook = OrderBook(descending_bids=bids, ascending_asks=asks)
```

The above code creates an `OrderBook` in the price range [91, 114] with a bid-ask spread of 5. Figure \ref{fig:order_book_0} depicts this `OrderBook` visually.

![Starting Order Book \label{fig:order_book_0}](./chapter9/order_book_0.png "Starting Order Book")

Let's submit a Sell LO that says we'd like to sell 40 shares as long as the transacted price is greater than or equal to 107. Our Sell LO should simply get added to the Sell LO side of the OB.

```python
ob1: OrderBook = ob0.sell_limit_order(107, 40)
```

The new `OrderBook` `ob1` has 40 more shares at the price level of 107, as depicted in Figure \ref{fig:order_book_1}.

![Order Book after Sell LO\label{fig:order_book_1}](./chapter9/order_book_1.png "Order Book after Sell LO")

Now let's submit a Sell MO that says we'd like to sell 120 shares at the "best price". Our Sell MO should transact with 120 shares at "best prices" of 100 and 99 as well (since the OB does not have enough Buy LO shares at the price of 100). 
```python
d_s, ob2 = ob1.sell_market_order(120)
```

The new `OrderBook` `ob2` has 120 less shares on the Buy LO side of the OB, as depicted in Figure \ref{fig:order_book_2}.   

![Order Book after Sell MO\label{fig:order_book_2}](./chapter9/order_book_2.png "Order Book after Sell MO")

Now let's submit a Buy LO that says we'd like to buy 80 shares as long as the transacted price is less than or equal to 100. Our Buy LO should get added to the Buy LO side of the OB.

```python
ob3: OrderBook = ob2.buy_limit_order(100, 80)
```

The new `OrderBook` `ob3` has re-introduced a Buy LO at the price level of 100 (now with 80 shares), as depicted in Figure \ref{fig:order_book_3}.

![Order Book after Buy LO\label{fig:order_book_3}](./chapter9/order_book_3.png "Order Book after Buy LO")

Now let's submit a Sell LO that says we'd like to sell 60 shares as long as the transacted price is greater than or equal to 104. Our Sell LO should get added to the Sell LO side of the OB.

```python
ob4: OrderBook = ob3.sell_limit_order(104, 60)
```

The new `OrderBook` `ob4` has introduced a Sell LO at a price of 104 with 60 shares, as depicted in Figure \ref{fig:order_book_4}.

![Order Book after 2nd Sell LO\label{fig:order_book_4}](./chapter9/order_book_4.png "Order Book after 2nd Sell LO")

Now let's submit a Buy MO that says we'd like to buy 150 shares at the "best price". Our Buy MO should transact with 150 shares at "best prices" on the Sell LO side of the OB.

```python
d_s, ob5 = ob4.buy_market_order(150)
```

The new `OrderBook` `ob5` has 150 less shares on the Sell LO side of the OB, wiping out all the shares at the price level of 104 and almost wiping out all the shares at the price level of 105, as depicted in Figure \ref{fig:order_book_5}.

![Order Book after Buy MO\label{fig:order_book_5}](./chapter9/order_book_5.png "Order Book after Buy MO")
   
This has served as a good test of our code (transactions working as we'd like) and we encourage you to write more code of this sort to interact with the `OrderBook`, and to produce graphs of evolution of the `OrderBook` as this will help develop stronger intuition and internalize the concepts we've learnt above. All of the above code is in the file [rl/chapter9/order_book.py](https://github.com/TikhonJelvis/RL-book/blob/master/rl/chapter9/order_book.py).

Now we are ready to get started with the problem of Optimal Execution of a large-sized Market Order.

## Optimal Execution of a Market Order

Imagine the following problem: You are a trader in a stock and your boss has instructed that you exit from trading in this stock because this stock doesn't meet your company's new investment requirements. You have to sell all of the $N$ shares you own in this stock in the next $T$ hours. You are allowed to submit sell market orders (of any size) at the start of each hour - so you have $T$ opportunities to submit market orders of any size. Your goal is to maximize the Expected Total Utility of proceeds from sales of all $N$ shares over the $T$ hours. Your task is to break up $N$ into $T$ appropriate chunks to maximize the Expected Total Utility objective. If you attempt to sell the $N$ shares too fast (i.e., too many in the first few hours), as we've learnt above, each (MO) sale will eat a lot into the Buy LOs on the OB (Temporary Price Impact) which would result in transacting at prices below the best price (Bid Price). Moreover, you risk moving the *Bid Price* on the OB significantly lower (Permanent Price Impact) that would affect the proceeds on the next few sales you'd make. On the other hand, if you sell the $N$ shares too slow (i.e., too few in the first few hours), you might transact at good prices but then you risk running out of time, which means you will have to dump a lot of shares with time running out which in turn would mean transacting at prices below the best price. Moreover, selling too slow exposes you to more uncertainty in market price movements over a longer time period, and more uncertainty in sales proceeds means the Expected Utility objective gets hurt. Thus, the precise timing and sizes in the breakup of shares is vital. You will need to have an estimate of the Temporary and Permanent Price Impact of your Market Orders, which can help you identify the appropriate number of shares to sell at the start of each hour.

Unsurprisingly, we can model this problem as a Market Decision Process control problem where the actions at each time step (each hour, in this case) are the number of shares sold at the time step and the rewards are the Utility of sales proceeds at each time step. To keep things simple and intuitive, we shall model *Price Impact* of Market Orders in terms of their effect on the *Bid Price* (rather than in terms of their effect on the entire OB). In other words, we won't be modeling the entire OB Price Dynamics, just the Bid Price Dynamics. We shall refer to the OB activity of an MO immediately "eating into the Buy LOs" (and hence, potentially transacting at prices lower than the best price) as the *Temporary* Price Impact. As mentioned earlier, this is followed by subsequent replenishment of both Buy and Sell LOs on the OB (stabilizing the OB) - we refer to any eventual (end of the hour) lowering of the Bid Price (relative to the Bid Price before the MO was submitted) as the *Permanent* Price Impact. Modeling the temporary and permanent Price Impacts separately helps us in deciding on the optimal actions (optimal shares to be sold at the start of each hour).

Now we develop some formalism to describe this problem precisely. As mentioned earlier, we make a number of simplifying assumptions in modeling the OB Dynamics for ease of articulation (without diluting the most important concepts). We index discrete time by $t= 0, 1, \ldots, T$.  We denote $P_t$ as the Bid Price at the start of time step $t$ (for all $t = 0, 1, \ldots, T$) and $N_t$ as the number of shares sold at time step $t$ for all $t = 0, 1, \ldots, T-1$. We denote the number of shares remaining to be sold at the start of time step $t$ as $R_t$ for all $t = 0, 1, \ldots, T$. Therefore,
$$R_t = N - \sum_{i=0}^{t-1}N_i \text{ for all } t = 0, 1, \ldots, T$$
Note that:

$$R_0 = N$$
$$R_{t+1} = R_t - N_t \text{ for all } t = 0, 1, \ldots, T-1$$

Also note that we need to sell everything by time $t=T$ and so:

$$N_{T-1} = R_{T-1} \Rightarrow R_T = 0$$

The model of Bid Price Dynamics from one time step to the next is given by:
$$P_{t+1} = f_t(P_t, N_t, \epsilon_t) \text{ for all } t = 0, 1, \ldots, T-1$$
where $f_t$ is an arbitrary function incorporating:

* The Permanent Price Impact of selling $N_t$ shares.
* The Price-Impact-independent market-movement of the Bid Price from time $t$ to time $t+1$.
* Noise $\epsilon_t$, a source of randomness in Bid Price movements.

The Proceeds from the sale at time step $t$, for all $t = 0, 1, \ldots, T-1$, is defined as:
$$N_t \cdot Q_t = N_t \cdot (P_t - g_t(P_t, N_t))$$
where $g_t$ is a function modeling the Temporary Price Impact (i.e., the $N_t$ MO "eating into" the Buy LOs on the OB). $Q_t$ should be interpreted as the average Buy LO price transacted against by the $N_t$ MO at time $t$.

Lastly, we denote the Utility (of Sales Proceeds) function as $U(\cdot)$.

As mentioned previously, solving for the optimal number of shares to be sold at each time step can be modeled as a discrete-time finite-horizon Markov Decision Process, which we describe below in terms of the order of MDP activity at each time step $t = 0, 1, \ldots, T-1$ (the MDP horizon is time $T$ meaning all states at time $T$ are terminal states). We follow the notational style of finite-horizon MDPs that should now be familiar from previous chapters.

Order of Events at time step $t$ for all $t = 0, 1, \ldots, T-1$:

* Observe *State* $s_t := (P_t, R_t) \in \mathcal{S}_t$
* Perform *Action* $a_t := N_t \in \mathcal{A}_t$
* Receive *Reward* $r_{t+1} := U(N_t \cdot Q_t) = U(N_t \cdot (P_t - g_t(P_t, N_t)))$
* Experience Price Dynamics $P_{t+1} = f_t(P_t, N_t, \epsilon_t)$ and set $R_{t+1} = R_t - N_t$ so as to obtain the next state $s_{t+1} = (P_{t+1}, R_{t+1}) \in \mathcal{S}_{t+1}$.

Note that we have intentionally not specified the types of $\mathcal{S}_t$ and $\mathcal{A}_t$ as the types will be customized to the nuances/constraints of the specific Optimal Order Execution problem we'd be solving. Be default, we shall assume that $P_t \in \mathbb{R}^+$ and $N_t, R_t \in \mathbb{Z}_{\geq 0}$ (as these represent realistic trading situations), although we do consider special cases later in the chapter where $P_t, R_t \in \mathbb{R}$ (for analytical tractability).

The goal is to find the Optimal Policy $\pi^* = (\pi^*_0, \pi^*_1, \ldots, \pi^*_{T-1})$ (defined as $\pi^*_t((P_t, R_t)) = N^*_t$ that maximizes:
$$\mathbb{E}[\sum_{t=0}^{T-1} \gamma^t \cdot U(N_t \cdot Q_t)]$$
where $\gamma$ is the discount factor to account for the fact that future utility of sales proceeds can be modeled to be less valuable than today's.

### Simple Linear Price Impact Model with no Risk-Aversion

Now we consider a special case of the above-described MDP - a simple linear Price Impact model with no risk-aversion. Furthermore, for analytical tractability, we assume $N, N_t, P_t$ are all continuous-valued (i.e., taking values $\in \mathbb{R}$).

We assume simple linear price dynamics as follows:

$$P_{t+1} = f_t(P_t, N_t, \epsilon) = P_t - \alpha \cdot N_t + \epsilon_t$$

where $\alpha \in \mathbb{R}$ and $\epsilon_t$ for all $t=0, 1, \ldots, T-1$ are independent and identically distributed (i.i.d.) with $\mathbb{E}[\epsilon_t|N_t, P_t] = 0$. Therefore, the Permanent Price Impact is $\alpha \cdot N_t$. 

As for the temporary price impact, we know that $g_t$ needs to be a monotonically non-decreasing function of $N_t$. We assume a simple linear form for $g_t$ as follows:

$$g_t(P_t, N_t) = \beta \cdot N_t \text{ for all } t = 0, 1, \ldots, T-1$$

for some constant $\beta \in \mathbb{R}_{\geq 0}$. So, $Q_t = P_t - \beta N_t$. As mentioned above, we assume no risk-aversion, i.e., the Utility function $U(\cdot)$ is assumed to be the identity function. Also, we assume that the MDP discount factor $\gamma = 1$.

Note that all of these assumptions are far too simplistic and hence, an unrealistic model of the real-world, but starting with this simple model helps build good intuition and enables us to develop more realistic models by incrementally adding complexity/nuances from this simple base model.

As ever, in order to solve the Control problem, we define the Optimal Value Function and invoke the Bellman Optimality Equation. We shall use the standard notation for discrete-time finite-horizon MDPs that we are now very familiar with.

Denote the Value Function for policy $\pi$ at time $t$ (for all $t = 0, 1, \ldots T-1$) as:

$$V^{\pi}_t((P_t, R_t)) = \mathbb{E}_{\pi}[\sum_{i=0}^{T-1} N_i \cdot (P_i - \beta \cdot N_i)|(t,P_t,R_t)]$$

Denote the Optimal Value Function at time $t$ (for all $t= 0, 1, \ldots, T-1$) as:

$$V^*_t((P_t,R_t)) = \max_{\pi} V^{\pi}_t((P_t,R_t))$$

The Optimal Value Function satisfies the finite-horizon Bellman Optimality Equation for all $t = 0, 1, \ldots, T-2$, as follows:
$$V^*_t((P_t,R_t)) = \max_{N_t} \{ N_t \cdot (P_t - \beta \cdot N_t)  + \mathbb{E}[V^*_{t+1}((P_{t+1}, R_{t+1}))] \}$$
and

$$V^*_{T-1}((P_{T-1},R_{T-1})) = N_{T-1} \cdot (P_{T-1} - \beta \cdot N_{T-1})) = R_{T-1} \cdot (P_{T-1} - \beta \cdot R_{T-1})$$

From the above, we can infer:

$$V^*_{T-2}((P_{T-2}, R_{T-2})) = \max_{N_{T-2}} \{ N_{T-2} \cdot (P_{T-2} - \beta \cdot N_{T-2})  + \mathbb{E}[R_{T-1} \cdot (P_{T-1} - \beta \cdot R_{T-1})] \}$$
$$=\max_{N_{T-2}} \{ N_{T-2} \cdot (P_{T-2} - \beta \cdot N_{T-2})  + \mathbb{E}[(R_{T-2} - N_{T-2})(P_{T-1} - \beta \cdot (R_{T-2} - N_{T-2})) \}$$
$$=\max_{N_{T-2}} \{ N_{T-2} \cdot (P_{T-2} - \beta \cdot N_{T-2})  + (R_{T-2} - N_{T-2}) \cdot (P_{T-2} - \alpha \cdot N_{T-2} - \beta \cdot (R_{T-2} - N_{T-2})) \}$$
This simplifies to:
\begin{equation}
V^*_{T-2}((P_{T-2}, R_{T-2})) = \max_{N_{T-2}} \{ R_{T-2} \cdot P_{T-2} - \beta \cdot R_{T-2}^2 + (\alpha - 2 \beta) (N_{T-2}^2 - N_{T-2} \cdot R_{T-2}) \}
\label{eq:optimal-exercise-linear-model-recursive}
\end{equation}

For the case $\alpha \geq 2\beta$, noting that $N_{T-2} \leq R_{T-2}$, we have the trivial solution:
$$N^*_{T-2} = 0 \text{ or } N^*_{T-2} = R_{T-2}$$

Substituting either of these two values for $N^*_{T-2}$ in the right-hand-side of Equation \eqref{eq:optimal-exercise-linear-model-recursive} gives:

$$V^*_{T-2}((P_{T-2}, R_{T-2})) =  R_{T-2} \cdot (P_{T-2} - \beta \cdot R_{T-2})$$

Continuing backwards in time in this manner (for the case $\alpha \geq 2\beta$) gives:

$$N^*_t = 0 \text{ or } N^*_t = R_t \text{ for all } t = 0, 1, \ldots, T-1$$
$$V^*_t((P_t, R_t)) = R_t \cdot (P_t - \beta \cdot R_t) \text{ for all } t = 0, 1, \ldots, T-1$$
So the solution for the case $\alpha \geq 2\beta$ is to sell all $N$ shares at any one of the time steps $t = 0, 1, \ldots, T-1$ (and none in the other time steps), and the Optimal Expected Total Sale Proceeds is $N \cdot (P_0 - \beta \cdot N)$

For the case $\alpha < 2\beta$, differentiating the term inside the $\max$ in Equation \eqref{eq:optimal-exercise-linear-model-recursive} with respect to $N_{T-2}$, and setting it to 0 gives:
$$(\alpha - 2\beta) \cdot (2N^*_{T-2} - R_{T-2}) = 0 \Rightarrow N^*_{T-2} = \frac {R_{T-2}} 2$$
Substituting this solution for $N^*_{T-2}$ in Equation \eqref{eq:optimal-exercise-linear-model-recursive} gives:

$$V^*_{T-2}((P_{T-2}, R_{T-2})) =  R_{T-2} \cdot P_{T-2} - R_{T-2}^2 \cdot (\frac {\alpha + 2\beta} 4)$$

Continuing backwards in time in this manner gives:

$$N^*_t = \frac {R_t} {T-t} \text{ for all } t = 0, 1, \ldots, T-1$$
$$V^*_t((P_t, R_t)) = R_t \cdot P_t - \frac {R_t^2} 2 \cdot (\frac {2\beta + \alpha \cdot (T-t-1)} {T-t}) \text{ for all } t = 0, 1, \ldots, T-1$$

Rolling forward in time, we see that $N^*_t = \frac N T$, i.e., splitting the $N$ shares uniformly across the $T$ time steps. Hence, the Optimal Policy is a constant deterministic function (i.e., independent of the *State*).  Note that a uniform split makes intuitive sense because Price Impact and Market Movement are both linear and additive, and don't interact. This optimization is essentially equivalent to minimizing $\sum_{t=1}^T N_t^2$ with the constraint: $\sum_{t=1}^T N_t = N$. The Optimal Expected Total Sales Proceeds is equal to:

$$N \cdot P_0 - \frac {N^2} 2 \cdot (\alpha + \frac {2\beta - \alpha} T)$$

*Implementation Shortfall* is the technical term used to refer to the reduction in Total Sales Proceeds relative to the maximum possible sales proceeds ($=N\cdot P_0$). So, in this simple linear model, the Implementation Shortfall from Price Impact is $\frac {N^2} 2 \cdot (\alpha + \frac {2\beta - \alpha} T)$. Note that the Implementation Shortfall is non-zero even if one had infinite time available ($T\rightarrow \infty$) for the case of $\alpha > 0$. If Price Impact were purely temporary ($\alpha = 0$, i.e., Price fully snapped back), then the Implementation Shortfall is zero if one had infinite time available.

[This paper by Bertsimas and Lo on Optimal Order Execution](http://alo.mit.edu/wp-content/uploads/2015/06/Optimal-Control-of-Execution-Costs.pdf) considered a special case of the simple Linear Impact model we sketched above. Specifically, they assumed no risk-aversion (Utility function is identity function) and assumed that the Permanent Price Impact parameter $\alpha$ is equal to the Temporary Price Impact Parameter $\beta$. In the same paper, Bertsimas and Lo then extended this Linear Impact Model to include dependence on a serially-correlated variable $X_t$ as follows:
$$P_{t+1} = P_t - (\beta \cdot N_t + \theta \cdot X_t) + \epsilon_t$$
$$X_{t+1} = \rho \cdot X_t + \eta_t$$
$$Q_t = P_t - (\beta \cdot N_t + \theta \cdot X_t)$$
where $\epsilon_t$ and $\eta_t$ are each independent and identically distributed for all $t = 0, 1, \ldots, T-1$,  $\epsilon_t$ and $\eta_t$ are also mutually independent, and each has mean zero. $X_t$ can be thought of as a market factor affecting $P_t$ linearly. Applying the finite-horizon Bellman Optimality Equation on the Optimal Value Function (and the same backward-recursive approach as before) yields:
$$N^*_t = \frac {R_t} {T-t} + h(t, \beta, \theta, \rho) \cdot X_t$$
$$V^*_t((P_t,R_t,X_t)) = R_t \cdot P_t - (\text{quadratic in } (R_t, X_t) + \text{ constant})$$
Essentially, the serial-correlation predictability ($\rho \neq 0$) alters the uniform-split strategy.

In the same paper, Bertsimas and Lo presented a more realistic model called *Linear-Percentage Temporary* (abbreviated as LPT) Price Impact model, whose salient features include:

* Geometric random walk: consistent with real data, and avoids non-positive prices.
* Fractional Price Impact $\frac {g_t(P_t,N_t)} {P_t}$ doesn't depend on $P_t$ (this is validated by real data).
* Purely Temporary Price Impact, i.e., the price $P_t$ snaps back after the Temporary Price Impact (no Permanent effect of Market Orders on future prices). 

The specific model is:

$$P_{t+1} = P_t \cdot e^{Z_t}$$
$$X_{t+1} = \rho \cdot X_t + \eta_t$$
$$Q_t = P_t \cdot (1 - \beta \cdot N_t - \theta \cdot X_t)$$
where $Z_t$ is a random variable with mean $\mu_Z$ and variance $\sigma^2_Z$. With the same derivation methodology as before, we get the solution:
$$N_t^* = c^{(1)}_t + c^{(2)}_t R_t + c^{(3)}_t X_t $$
$$V^*_t((P_t,R_t,X_t)) = e^{\mu_Z + \frac {\sigma_Z^2} 2} \cdot P_t \cdot (c^{(4)}_t + c^{(5)}_t R_t + c^{(6)}_t X_t + c^{(7)}_t R_t^2 + c^{(8)}_t X_t^2 + c^{(9)}_t R_t X_t)$$
where $c^{(k)}_t, 1 \leq k \leq 9$, are independent of $P_t, R_t, X_t$

### Incorporating Risk-Aversion and Real-World Considerations

## Optimal Market-Making

### Avellaneda-Stoikov Continuous-Time Formulation
### Solving the Avellaneda-Stoikov Formulation
### Real-World Market-Making

## Key Takeaways from this Chapter
