# Order Book Algorithms {#sec:order-book-algos-chapter}

In this chapter, we venture into the world of Algorithmic Trading and specifically, we cover a couple of problems involving a trading *Order Book* that can be cast as Markov Decision Processes, and hence tackled with Dynamic Programming or Reinforcement Learning. We start the chapter by covering the basics of how trade orders are submitted and executed on an *Order Book*, a structure that allows for efficient transactions between buyers and sellers of a financial asset. Without loss of generality, we refer to the financial asset being traded on the Order Book as a "stock" and the number of units of the asset as "shares". Next we will explain how a large trade can significantly shift the Order Book, a phenomenon known as *Price Impact*. Finally, we will cover the two algorithmic problems that can be cast as MDPs. The first problem is Optimal Execution of the sales of a large number of shares of a stock so as to yield the maximum utility of proceeds from the sale over a finite horizon. This involves breaking up the sale of the shares into appropriate pieces and selling those pieces at the right times so as to achieve the  goal of maximizing the utility of sales proceeds. Hence, it is an MDP  Control problem where the actions are the number of shares sold at each time step. The second problem is Optimal Market-Making, i.e., the optimal "bid"s (willingness to buy a certain number of shares at a certain price) and "ask"s (willingness to sell a certain number of shares at a certain price) to be submitted on the Order Book. Again, by optimal, we mean maximization of the utility of revenues generated by the market-maker over a finite-horizon (market-makers generate revenue through the spread, i.e. gap, between the bid and ask prices they offer). This is also an MDP Control problem where the actions are the bid and ask prices along with the bid and ask shares at each time step.

![Trading Order Book \label{fig:trading_order_book}](./chapter9/order_book.png "Trading Order Book")

## Basics of Order Book and Price Impact

Some of the financial literature refers to the Order Book as Limit Order Book (abbreviated as LOB) but we will stick with the lighter language - Order Book, abbreviated as OB. The Order Book is essentially a data structure that facilitates matching stock buyers with stock sellers (i.e., an electronic marketplace). Figure \ref{fig:trading_order_book} depicts a simplified view of an order book. In this order book market, buyers and sellers express their intent to trade by submitting bids (intent to buy) and "ask"s (intent to sell). These expressions of intent to buy or sell are known as Limit Orders (abbreviated as LO). The word "limit" in Limit Order refers to the fact that one is interested in buying only below a certain price level (and likewise, one is interested in selling only above a certain price level). Each LO is comprised of a price $P$ and a size (number of shares) $N$. A bid, i.e., Buy LO $(P, N)$ states willingness to buy $N$ shares at a price less than or equal to $P$. Likewise, an ask, i.e., a Sell  LO $(P, N)$ states willingness to sell $N$ shares at a price greater than or equal to $P$.

Note that multiple traders might submit LOs with the same price. The order book aggregates the order sizes (number of shares) for each unique price, and the OB data structure is typically presented for trading in the form of this aggregated view. Thus, the OB data structure can be represented as two sorted lists of (Price, Size) pairs:

$$\text{Buy LOs (Bids): } [(P_i^{(b)}, N_i^{(b)}) \mid 0 \leq i < m], P_i^{(b)} > P_j^{(b)} \mbox{ for } i < j$$
$$\text{Sell LOs (Asks): } [(P_i^{(a)}, N_i^{(a)}) \mid 0 \leq i < n], P_i^{(a)} < P_j^{(a)} \mbox{ for } i < j$$

Now let's learn about some of the standard terminology:

* We refer to $P_0^{(b)}$ as *The Bid Price* (often lightened to the single word *Bid* ) to signify that it is the highest offer to buy and hence, the *best* price for a seller to transact with.
* Likewise, we refer to $P_0^{(a)}$ as *The Ask Price* (often lightened to the single word *Ask*) to signify that it is the lowest offer to sell and hence, the *best* price for a buyer to transact with.
* $\frac {P_0^{(a)} + P_0^{(b)}} 2$ is refered to as the *The Mid Price* (often lightened to the single word *Mid*).
* $P_0^{(a)} - P_0^{(b)}$ is refered to as *The Bid-Ask Spread* (often lightened to the single word *Spread*).
* $P_{n-1}^{(a)} - P_{m-1}^{(b)}$ is refered to as *The Market Depth* (often lightened to the single word *Depth*).

Although an actual real-world trading order book has many other small details, we believe this simplified coverage is adequate for the purposes of core understanding of order book trading and to navigate the problems of optimal order execution and optimal market-making. Apart from Limit Orders, traders can express their interest to buy/sell with another type order - a *Market Order* (abbreviated as MO). A Market Order (MO) states one's intent to buy/sell $N$ shares at the *best possible price(s)* available on the OB at the time of MO submission. So, an LO is keen on price and not so keen on time (willing to wait to get the price one wants) while an MO is keen on time (desire to trade right away) and not so keen on price (will take whatever the best LO price is on the OB). So now let us understand the actual transactions that happens between LOs and MOs (buy and sell interactions, and how the OB changes as a result of these interactions). Firstly, we note that in normal trading activity, a newly submitted sell LO's price is typically above the price of the best buy LO on the OB. But if a new sell LO's price is less than or equal to the price of the best buy LO's price, we say that the *market has crossed* (to mean that the range of bid prices and the range of ask prices have intersected), which results in an immediate transaction that eats into the OB's Buy LOs.

Precisely, a new Sell LO $(P,N)$ potentially transacts with (and hence, removes) the best Buy LOs on the OB.
\begin{equation}
\text{Removal: } [(P_i^{(b)}, \min(N_i^{(b)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(b)}))) \mid (i: P_i^{(b)} \geq P)]
\label{eq:lo_sell_remove}
\end{equation}
After this removal, it potentially adds the following LO to the asks side of the OB:
\begin{equation}
(P, \max(0, N - \sum_{i: P_i^{(b)} \geq P}  N_i^{(b)}))
\label{eq:lo_sell_add}
\end{equation}

Likewise, a new Buy MO $(P,N)$ potentially transacts with (and hence, removes) the best Sell LOs on the OB
\begin{equation}
\text{Removal: } [(P_i^{(a)}, \min(N_i^{(a)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(a)}))) \mid (i: P_i^{(a)} \leq P)]
\label{eq:lo_buy_remove}
\end{equation}
After this removal, it potentially adds the following to the bids side of the OB:
\begin{equation}
(P, \max(0, N - \sum_{i: P_i^{(a)} \leq P}  N_i^{(a)}))
\label{eq:lo_buy_add}
\end{equation}

When a Market Order (MO) is submitted, things are simpler. A Sell Market Order of size $N$ will remove the best Buy LOs on the OB.
\begin{equation}
\mbox{Removal: } [(P_i^{(b)}, \min(N_i^{(b)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(b)}))) \mid 0 \leq i < m]
\label{eq:mo_sell_remove}
\end{equation}
Likewise, a Buy Market Order of size $N$ will remove the best Sell LOs on the OB
\begin{equation}
\mbox{Removal: } [(P_i^{(a)}, \min(N_i^{(a)}, \max(0, N - \sum_{j=0}^{i-1} N_j^{(a)}))) \mid 0 \leq i < n]
\label{eq:mo_buy_remove}
\end{equation}

We focus on how a Market order (MO) alters the OB. A large-sized MO will typically remove a large volume of LOs on the OB, which results in a big *Bid-Ask Spread*, which would typically soon be replenished by new LOs, potentially from either the bid side or the ask side. So a large-sized MO moves the Bid/Ask/Mid Price (i.e., it moves the prices of the best Buy and Sell LOs). This movement of the Bid/Ask/Mid is known as the *Price Impact of a Market Order*. The subsequent LO replenishment activity constitutes what is known as *Order Book Dynamics* in response to the price movements triggered by an MO. There is considerable literature on modeling Order Book Dynamics and some of these models can get fairly complex to capture various real-world nuances. Much of this literature is beyond the scope of this book. In this chapter, we will cover a few simple models for how a sell MO will move the OB's *Bid Price* (rather than a model for how it will move the entire OB). The model for how a buy MO will move the OB's *Ask Price* will be identical.

Now let's write some code that models how LOs and MOs interact with the OB. We write a class `OrderBook` that represents the Buy and Sell Limit Orders on the Order Book. `PriceSizePairs` is the alias for a sequence of (Price, Size) pairs and the `OrderBook` maintains a price-descending sequence of `PriceSizePairs` for Buy LOs (`descending_bids`) and a price-ascending sequence of `PriceSizePairs` for Sell LOs (`ascending_asks`). We write the basic methods to get the `OrderBook`'s highest bid price (method `bid_price`), lowest ask price (method `ask_price`), mid price (method `mid_price`), spread between the highest bid price and lowest ask price (method `bid_ask_spread`), and market depth (method `market_depth`).

```python
PriceSizePairs = Sequence[Tuple[float, int]]

@dataclass(frozen=True)
class OrderBook:

    descending_bids: PriceSizePairs
    ascending_asks: PriceSizePairs

    def bid_price(self) -> float:
        return self.descending_bids[0][0]

    def ask_price(self) -> float:
        return self.ascending_asks[0][0]

    def mid_price(self) -> float:
        return (self.bid_price() + self.ask_price()) / 2

    def bid_ask_spread(self) -> float:
        return self.ask_price() - self.bid_price()

    def market_depth(self) -> float:
        return self.ascending_asks[-1][0] - self.descending_bids[-1][0]
```

Next we want to write methods for LOs and MOs to interact with the `OrderBook`. Notice that each of Equation \eqref{eq:lo_sell_remove} (new Sell LO potentially removing some of the beginning of the Buy LOs on the OB), Equation \eqref{eq:lo_buy_remove} (new Buy LO potentially removing some of the beginning of the Sell LOs on the OB), Equation \eqref{eq:mo_sell_remove} (Sell MO removing some of the beginning of the Buy LOs on the OB) and Equation \eqref{eq:mo_buy_remove} (Buy MO removing some of the beginning of the Sell LOs on the OB) all perform a common core function - they "eat into" the most significant LOs (on the opposite side) on the OB. So we first write a `@staticmethod eat_book` for this common function. `eat_book` takes as input a `PriceSizePairs` data structure and the number of shares to buy/sell, and deletes (i.e. "eats up") as much of the *beginning* of the `PriceSizePairs` data structure as it can (basically matching the input number of shares with an appropriate number of shares at the beginning of the `PriceSizePairs` input). `eat_book` returns the number of shares that couldn't be matched (positive if the `PriceSizePairs` input doesn't have enough shares), and the remainder of the `PriceSizePairs` after it has been appropriately eaten up (non-empty if the input number of shares is not large enough to eat the entire `PriceSizePairs` input). 

```python
    @staticmethod
    def eat_book(
        book: PriceSizePairs,
        size: int
    ) -> Tuple[int, PriceSizePairs]:
        rem_size: int = size
        for i, (this_price, this_size) in enumerate(book):
            if rem_size < this_size:
                return (0, [(this_price, this_size - rem_size)] +
                        list(book[i+1:]))
            else:
                rem_size -= this_size

        return (rem_size, [])
```

Now we are ready to write the method `sell_limit_order` which takes a (Sell MO Price, Sell MO Size) pair as input. As you can see in the code below, it potentially removes (if it "crosses") an appropriate number of shares on the Buy LO side of the OB (using the `@staticmethod eat_book`), and then potentially adds an appropriate number of shares at the Sell MO Price on the Sell MO side of the OB. `sell_limit_order` returns a new instance of `OrderBook` representing the altered OB after this transaction (note the use of the `replace` method that ensures the immutability of the `OrderBook` data structures, i.e., a fresh modified data structure is created and returned). We request you to read the code below carefully as there are many subtle edge cases that are handled in the code.

```python
    def sell_limit_order(self, price: float, size: int) -> OrderBook:
        index: Optional[int] = next((i for i, (p, _)
                                     in enumerate(self.descending_bids)
                                     if p < price), None)
        eligible_bids: PriceSizePairs = self.descending_bids \
            if index is None else self.descending_bids[:index]
        ineligible_bids: PriceSizePairs = [] if index is None else \
            self.descending_bids[index:]

        rem_size, rem_bids = OrderBook.eat_book(eligible_bids, size)

        new_bids: PriceSizePairs = list(rem_bids) + list(ineligible_bids)
        if rem_size > 0:
            asks_copy: List[Tuple[float, int]] = list(self.ascending_asks)
            index1: Optional[int] = next((i for i, (p, _)
                                          in enumerate(asks_copy)
                                          if p >= price), None)
            if index1 is None:
                asks_copy.append((price, rem_size))
            elif asks_copy[index1][0] != price:
                asks_copy.insert(index1, (price, rem_size))
            else:
                asks_copy[index1] = (price, asks_copy[index1][1] + rem_size)
            return replace(
                self,
                ascending_asks=asks_copy,
                descending_bids=new_bids
            )
        else:
            return replace(
                self,
                descending_bids=new_bids
            )
```

Next, we write the easier method `sell_market_order` which takes as input the number of shares to be sold (as a market order), and transacts with the appropriate number of shares on the Buy LOs side of the OB (removing those many shares from the Buy LOs side). It returns the number of shares that could not be sold (positive if the Buy LOs on the OB did not have sufficient shares) and a new instance of the `OrderBook` data structure representing the altered OB after this transaction (again, note the use of the `replace` method that ensures immutability of the `OrderBook` data structures, i.e., a fresh modified data structure is created and returned).

```python
    def sell_market_order(self, size: int) -> Tuple[int, OrderBook]:
        rem_size, rem_bids = OrderBook.eat_book(
            self.descending_bids,
            size
        )
        return (rem_size, replace(self, descending_bids=rem_bids))
```

We won't list the methods `buy_limit_order` and `buy_market_order` here as they are completely analogous (you can find the entire code for `OrderBook` in the file [rl/chapter9/order_book.py](https://github.com/TikhonJelvis/RL-book/blob/master/rl/chapter9/order_book.py)). Now let us test out this code by creating a sample `OrderBook` and submitting some LOs and MOs to transact with the `OrderBook`.

```python
bids: PriceSizePairs = [(x, poisson(100. - (100 - x) * 10))
                        for x in range(100, 90, -1)]
asks: PriceSizePairs = [(x, poisson(100. - (x - 105) * 10))
                        for x in range(105, 115, 1)]

ob0: OrderBook = OrderBook(descending_bids=bids, ascending_asks=asks)
```

The above code creates an `OrderBook` in the price range [91, 114] with a bid-ask spread of 5. Figure \ref{fig:order_book_0} depicts this `OrderBook` visually.

![Starting Order Book \label{fig:order_book_0}](./chapter9/order_book_0.png "Starting Order Book")

Let's submit a Sell LO that says we'd like to sell 40 shares as long as the transacted price is greater than or equal to 107. Our Sell LO should simply get added to the Sell LO side of the OB.

```python
ob1: OrderBook = ob0.sell_limit_order(107, 40)
```

The new `OrderBook` `ob1` has 40 more shares at the price level of 107, as depicted in Figure \ref{fig:order_book_1}.

![Order Book after Sell LO\label{fig:order_book_1}](./chapter9/order_book_1.png "Order Book after Sell LO")

Now let's submit a Sell MO that says we'd like to sell 120 shares at the "best price". Our Sell MO should transact with 120 shares at "best prices" of 100 and 99 as well (since the OB does not have enough Buy LO shares at the price of 100). 
```python
_, ob2 = ob1.sell_market_order(120)
```

The new `OrderBook` `ob2` has 120 less shares on the Buy LO side of the OB, as depicted in Figure \ref{fig:order_book_2}.   

![Order Book after Sell MO\label{fig:order_book_2}](./chapter9/order_book_2.png "Order Book after Sell MO")

Now let's submit a Buy LO that says we'd like to buy 80 shares as long as the transacted price is less than or equal to 100. Our Buy LO should get added to the Buy LO side of the OB.

```python
ob3: OrderBook = ob2.buy_limit_order(100, 80)
```

The new `OrderBook` `ob3` has re-introduced a Buy LO at the price level of 100 (now with 80 shares), as depicted in Figure \ref{fig:order_book_3}.

![Order Book after Buy LO\label{fig:order_book_3}](./chapter9/order_book_3.png "Order Book after Buy LO")

Now let's submit a Sell LO that says we'd like to sell 60 shares as long as the transacted price is greater than or equal to 104. Our Sell LO should get added to the Sell LO side of the OB.

```python
ob4: OrderBook = ob3.sell_limit_order(104, 60)
```

The new `OrderBook` `ob4` has introduced a Sell LO at a price of 104 with 60 shares, as depicted in Figure \ref{fig:order_book_4}.

![Order Book after 2nd Sell LO\label{fig:order_book_4}](./chapter9/order_book_4.png "Order Book after 2nd Sell LO")

Now let's submit a Buy MO that says we'd like to buy 150 shares at the "best price". Our Buy MO should transact with 150 shares at "best prices" on the Sell LO side of the OB.

```python
_, ob5 = ob4.buy_market_order(150)
```

The new `OrderBook` `ob5` has 150 less shares on the Sell LO side of the OB, wiping out all the shares at the price level of 104 and almost wiping out all the shares at the price level of 105, as depicted in Figure \ref{fig:order_book_5}.

![Order Book after Buy MO\label{fig:order_book_5}](./chapter9/order_book_5.png "Order Book after Buy MO")
   
This has served as a good test of our code (transactions working as we'd like) and we encourage you to write more code of this sort to interact with the `OrderBook`, and to produce graphs of evolution of the `OrderBook` as this will help develop stronger intuition and internalize the concepts we've learnt above. All of the above code is in the file [rl/chapter9/order_book.py](https://github.com/TikhonJelvis/RL-book/blob/master/rl/chapter9/order_book.py).

Now we are ready to get started with the problem of Optimal Execution of a large-sized Market Order.

## Optimal Execution of a Market Order


## Simple Linear Impact Model with no Risk-Aversion
## Incorporating Risk-Aversion and Real-World Considerations
## Optimal Market-Making
## Avellaneda-Stoikov Continuous-Time Formulation
## Solving the Avellaneda-Stoikov Formulation
## Real-World Market-Making
