#!/usr/bin/env python3
import os
from os.path import basename, splitext
import subprocess
import sys

import fire

def all_chapters():
    """
    Parse the structure file (in the top level of the repo) to get a
    list of chapters in the order they appear in the book.

    Empty lines and lines starting from # in the structure file are
    ignored.
    """
    with open("structure", "r") as structure:
        return [
            chapter.strip() for chapter in structure
            if len(chapter) > 0
            if chapter[0] != "#"
            if not chapter.isspace()
        ]


def chapter_name(chapter):
    """
    We want accept several different formats to specify the chpater:

      • chapter1
      • chapter1/chapter1
      • chapter1/chapter1.md
      • book/chapter1/chapter1.md

    This function takes an input formatted like above and normalizes
    to just the name of the chapter (ie chapter1 in the above example).
    """
    name, _ = splitext(basename(chapter))
    return name
    

def run_pandoc(out, to, tf_format, chapter):
    """
    Run pandoc to compile either the entire book or just a single
    chapter.

    Returns a relative path to the generated document (pdf/tex/etc
    file).
    """
    book = chapter is None
    toc = ["--toc"] if book else []

    extension = "tex" if to == "latex" else to

    if tf_format:
        print("Using T&F format.")

    if book:
        chapters = [f"{name}/{name}.md" for name in all_chapters()]

        if out is None:
            out = f"Foundations of Reinforcement Learning.{extension}"

        chapter_list = "\n".join(chapters)
        print(f"Building {out} from:\n{chapter_list}")
    else:
        name = chapter_name(chapter)
        chapters = [f"{name}/{name}.md"]

        if out is None:
            out = f"{name}.{extension}"

        print(f"Converting book/{chapters[0]} to {out}")

    tf_settings = [
        "--metadata", "tf-format",
        "--lua-filter", "../bin/remove-hyperref.lua"
    ] if tf_format else []

    os.chdir("book")
    subprocess.run([
        "pandoc",
        "--to", to,
        "--output", f"../{out}",
        "--metadata", "chapters",
        "--metadata", "title='Foundations of Reinforcement Learning with Applications in Finance'",
        "--metadata", "author='Ashwin Rao, Tikhon Jelvis'",
        "--metadata", "reference-section-title='Bibliography'",
        "--filter", "pandoc-crossref",
        "--pdf-engine", "xelatex",
        "--template", "../templates/latex.template",
        "--top-level-division", "part",
        "--lua-filter", "../bin/alon-style-quotes.lua",
        "--citeproc",
        "--bibliography", "bibliography.bib",
    ] + toc + tf_settings + chapters)
    os.chdir("..")

    return out

def pdf_to_grayscale(pdf, out=None):
    """
    Use the gs command to convert a PDF at the given path to
    grayscale.
    """
    if out is None:
        out = pdf

    subprocess.run([
        "gs",
        f"-sOutputFile={out}",
        "-sDEVICE=pdfwrite",
        "-sColorConversionStrategy=Gray",
        "-dProcessColorModel=/DeviceGray",
        "-dCompatibilityLevel=1.4",
        "-dNOPAUSE",
        "-dBATCH",
        pdf
    ], check=True, capture_output=True)

def main(chapter=None, *, tf_format=False, out=None, to="pdf", gray=False):
    """
    Usage: bin/to-pdf [chapter] [--tf-format] [--out|-o=<out-path>] [--to=pdf|tex]

    Compile either the entire book or a single chapter.  Needs to run
    in a Nix shell and from the top-level directory fo the repo.
    """
    if "DEJA_VU_DIRECTORY" not in os.environ:
        print("DEJA_VU_DIRECTORY variable not set.")
        print("Try restarting your Nix shell.")
        sys.exit(1)

    out = run_pandoc(out, to, tf_format, chapter)

    if gray:
        if to != "pdf":
            print(f"Can only generate grayscale version for --to=pdf, not --to={to}")
            sys.exit(1)

        try:
            pdf_to_grayscale(out, f"gray-{out}")
            print(f"Grayscale version of {out} at gray-{out}")
        except subprocess.CalledProcessError as e:
            print("Failed to generate grayscale version of PDF")
            print(e.stderr)
            sys.exit(1)

if __name__ == "__main__":
    fire.Fire(main)
